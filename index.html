<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maddy's Love Story Adventure üíï</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        html { overflow: hidden; }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            background: #000;
            width: 100vw;
            height: 100vh;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        .ui-container {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            pointer-events: none;
        }
        .heart-counter {
            position: absolute;
            top: 20px; left: 20px;
            font-size: 16px;
            color: #FF0000;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            background: rgba(0,0,0,0.3);
            padding: 10px 15px;
            border-radius: 5px;
        }
        .instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            color: #FFF;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            text-align: center;
            animation: pulse 1s infinite;
        }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.6; } }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        .screen-overlay {
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: auto;
            flex-direction: column;
            text-align: center;
            padding: 40px;
            animation: fadeIn 0.5s;
        }
        .screen-overlay.hidden { display: none; pointer-events: none; }
        .screen-content {
            max-width: 90%; max-height: 90vh; overflow-y: auto;
            background: #FFF8DC;
            border: 6px solid #000;
            box-shadow: inset 0 0 0 3px #FFF, 0 0 0 6px #8B0000;
            padding: 28px 24px;
            image-rendering: pixelated;
        }
        .mario-title {
            font-size: clamp(18px, 4vw, 28px);
            color: #FFF;
            margin-bottom: 24px;
            text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 2px 2px 0 #000;
            letter-spacing: 1px;
        }
        .mario-subtitle {
            font-size: clamp(12px, 2.5vw, 18px);
            color: #F7DC00;
            margin-bottom: 16px;
            text-shadow: 2px 2px 0 #000, -1px -1px 0 #000, 1px 1px 0 #000;
        }
        .screen-overlay h1 { font-size: clamp(20px, 3.5vw, 32px); color: #FFF; margin-bottom: 24px; text-shadow: 2px 2px 0 #000, -1px -1px 0 #000, 1px 1px 0 #000; }
        .screen-overlay h2 { font-size: clamp(14px, 2.5vw, 20px); color: #F7DC00; margin-bottom: 16px; text-shadow: 2px 2px 0 #000, -1px -1px 0 #000; }
        .screen-overlay p { font-size: 10px; color: #000; line-height: 1.8; margin-bottom: 16px; }
        .memory-text {
            font-size: 10px; color: #000; line-height: 1.9; margin: 16px 0;
            max-height: 200px; overflow-y: auto;
            background: #FFF;
            padding: 16px;
            border: 3px solid #000;
            box-shadow: inset 0 0 0 1px #666;
        }
        .button {
            background: #E52521;
            border: 4px solid #000;
            color: #FFF;
            padding: 12px 24px;
            font-size: 12px;
            font-family: 'Press Start 2P', cursive;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.15s;
            box-shadow: 0 4px 0 #8B0000, 0 5px 0 #000;
            text-transform: uppercase;
            text-shadow: 2px 2px 0 #000;
        }
        .button:hover { transform: translateY(2px); box-shadow: 0 2px 0 #8B0000, 0 3px 0 #000; }
        .button:active { transform: translateY(4px); box-shadow: 0 0 0 #8B0000, 0 1px 0 #000; }
        .button:disabled { opacity: 0.6; cursor: not-allowed; }
        .start-screen h1 { font-size: clamp(22px, 5vw, 36px); margin-bottom: 28px; color: #FFF; text-shadow: 3px 3px 0 #000, -1px -1px 0 #000, 1px 1px 0 #000, 2px 2px 0 #8B0000; }
        .intro-text { font-size: 10px; line-height: 2; margin: 24px 0; color: #000; }
        .end-screen h1 { font-size: clamp(20px, 4vw, 28px); margin-bottom: 24px; color: #F7DC00; text-shadow: 2px 2px 0 #000, -1px -1px 0 #000; }
        .end-screen .final-message { font-size: 10px; color: #000; margin: 20px 0; font-style: italic; }
        .journey-text { font-size: 10px; color: #000; margin: 16px 0; line-height: 2; }
        .hearts-collected { font-size: clamp(24px, 6vw, 40px); color: #E52521; margin: 16px 0; text-shadow: 2px 2px 0 #000; }
        #loadingText { font-size: 12px; color: #000; margin-top: 16px; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <div class="ui-container">
        <div class="heart-counter">üíï Hearts: <span id="heartCount">0</span>/7</div>
        <div class="instructions" id="instructions">ARROW keys to move, SPACE or TAP to jump!</div>
    </div>
    <div class="screen-overlay" id="startScreen">
        <div class="screen-content">
            <h1 class="start-screen">Maddy's Love Story<br>Adventure üíï</h1>
            <div class="intro-text">
                <p>Four years ago, we met as project partners in college.</p>
                <p>We became inseparable best friends.</p>
                <p>And now... you're the love of my life.</p>
                <br>
                <p>Collect 7 hearts across the level to relive our</p>
                <p>beautiful memories together! üíï</p>
            </div>
            <p id="loadingText">Loading...</p>
            <button class="button" id="startBtn" onclick="startGame()" disabled>START GAME ‚ù§Ô∏è</button>
        </div>
    </div>
    <div class="screen-overlay hidden" id="memoryScreen">
        <div class="screen-content">
            <h2 id="memoryTitle"></h2>
            <div class="memory-text" id="memoryText"></div>
            <button class="button" onclick="closeMemory()">Continue ‚ù§Ô∏è</button>
        </div>
    </div>
    <div class="screen-overlay hidden" id="endScreen">
        <div class="screen-content">
            <h1 class="end-screen">üéâ YOU DID IT! üéâ</h1>
            <p>You collected all 7 hearts and unlocked our love story!</p>
            <div class="hearts-collected">‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è ‚ù§Ô∏è</div>
            <div class="journey-text">
                <p>Strangers ‚Üí Best Friends ‚Üí The Love of My Life</p>
                <br>
                <p class="final-message">"Every moment with you is my favorite memory"</p>
                <br>
                <p>Happy Valentine's Day!</p>
                <p>I love you! üíï</p>
            </div>
            <button class="button" onclick="restartGame()">PLAY AGAIN üéÆ</button>
        </div>
    </div>

    <script>
(function() {
    'use strict';

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // ---- Sprites: Mario from [Super-Mario-Bros-1-1-in-Unity](https://github.com/Hammania689/Super-Mario-Bros-1-1-in-Unity); ground/heart generated. ----
    // Mario sprite sheet frame rects (from Unity .meta, row y=341): [sx, sy, sw, sh].
    const MARIO_SHEET_Y = 341;
    const MARIO_RUN_FRAMES = [
        [142, MARIO_SHEET_Y, 16, 16],
        [161, MARIO_SHEET_Y, 13, 16],
        [177, MARIO_SHEET_Y, 15, 16],
        [195, MARIO_SHEET_Y, 11, 16]
    ];
    const MARIO_JUMP_FRAME = [239, MARIO_SHEET_Y, 16, 24];

    var useFallbackCharacter = false;

    function generateCharacterSheetFallback() {
        var c = document.createElement('canvas');
        c.width = 160;
        c.height = 48;
        var cctx = c.getContext('2d');
        var capRed = '#E52521', skin = '#F8C898', overallBlue = '#0165B3', shoeBrown = '#8B4513', white = '#FFFFFF', black = '#000000';
        for (var frame = 0; frame < 5; frame++) {
            var ox = frame * 32, legOffset = frame % 2 === 0 ? 0 : 2;
            cctx.fillStyle = capRed;
            cctx.fillRect(ox + 4, 2, 24, 8);
            cctx.fillRect(ox + 8, 0, 16, 4);
            cctx.fillStyle = white;
            cctx.fillRect(ox + 4, 4, 10, 3);
            cctx.fillRect(ox + 12, 2, 6, 5);
            cctx.fillStyle = '#5C3317';
            cctx.fillRect(ox + 20, 4, 8, 4);
            cctx.fillStyle = skin;
            cctx.fillRect(ox + 6, 10, 20, 14);
            cctx.fillStyle = black;
            cctx.fillRect(ox + 8, 12, 3, 3);
            cctx.fillRect(ox + 19, 12, 3, 3);
            cctx.fillRect(ox + 6, 18, 6, 2);
            cctx.fillRect(ox + 20, 18, 6, 2);
            cctx.fillStyle = capRed;
            cctx.fillRect(ox + 6, 24, 20, 12);
            cctx.fillStyle = overallBlue;
            cctx.fillRect(ox + 8, 24, 16, 10);
            cctx.fillRect(ox + 10, 24, 4, 12);
            cctx.fillRect(ox + 18, 24, 4, 12);
            cctx.fillStyle = white;
            cctx.fillRect(ox + 12, 26, 2, 2);
            cctx.fillRect(ox + 18, 26, 2, 2);
            cctx.fillStyle = skin;
            cctx.fillRect(ox + 2, 26, 5, 10);
            cctx.fillRect(ox + 25, 26, 5, 10);
            cctx.fillStyle = white;
            cctx.fillRect(ox + 2, 34, 5, 5);
            cctx.fillRect(ox + 25, 34, 5, 5);
            cctx.fillStyle = overallBlue;
            cctx.fillRect(ox + 6 + legOffset, 36, 8, 12);
            cctx.fillRect(ox + 18 - legOffset, 36, 8, 12);
            cctx.fillStyle = shoeBrown;
            cctx.fillRect(ox + 6 + legOffset, 46, 8, 2);
            cctx.fillRect(ox + 18 - legOffset, 46, 8, 2);
        }
        return c.toDataURL('image/png');
    }

    function generateGroundTile() {
        const c = document.createElement('canvas');
        c.width = 40;
        c.height = 40;
        const cctx = c.getContext('2d');
        // Mario-style brick: orange-brown with dark outline and pits
        cctx.fillStyle = '#C87838';
        cctx.fillRect(0, 0, 40, 40);
        cctx.strokeStyle = '#8B4513';
        cctx.lineWidth = 2;
        cctx.strokeRect(1, 1, 38, 38);
        cctx.fillStyle = '#A06020';
        cctx.fillRect(6, 6, 4, 4);
        cctx.fillRect(30, 6, 4, 4);
        cctx.fillRect(6, 30, 4, 4);
        cctx.fillRect(30, 30, 4, 4);
        return c.toDataURL('image/png');
    }

    function generateHeartSprite() {
        const size = 16;
        const c = document.createElement('canvas');
        c.width = size;
        c.height = size;
        const cctx = c.getContext('2d');
        const red = '#E52521';
        const dark = '#8B0000';
        const highlight = '#FF6B6B';
        const px = function(x, y) { cctx.fillRect(x, y, 1, 1); };
        cctx.fillStyle = dark;
        px(2, 2); px(3, 2); px(4, 2); px(5, 2); px(6, 2); px(7, 2); px(8, 2); px(9, 2); px(10, 2); px(11, 2); px(12, 2); px(13, 2);
        px(1, 3); px(2, 3); px(3, 3); px(4, 3); px(5, 3); px(6, 3); px(7, 3); px(8, 3); px(9, 3); px(10, 3); px(11, 3); px(12, 3); px(13, 3); px(14, 3);
        px(0, 4); px(1, 4); px(2, 4); px(3, 4); px(4, 4); px(5, 4); px(6, 4); px(7, 4); px(8, 4); px(9, 4); px(10, 4); px(11, 4); px(12, 4); px(13, 4); px(14, 4); px(15, 4);
        px(0, 5); px(1, 5); px(2, 5); px(3, 5); px(4, 5); px(5, 5); px(6, 5); px(7, 5); px(8, 5); px(9, 5); px(10, 5); px(11, 5); px(12, 5); px(13, 5); px(14, 5); px(15, 5);
        px(0, 6); px(1, 6); px(2, 6); px(3, 6); px(4, 6); px(5, 6); px(6, 6); px(7, 6); px(8, 6); px(9, 6); px(10, 6); px(11, 6); px(12, 6); px(13, 6); px(14, 6); px(15, 6);
        px(1, 7); px(2, 7); px(3, 7); px(4, 7); px(5, 7); px(6, 7); px(7, 7); px(8, 7); px(9, 7); px(10, 7); px(11, 7); px(12, 7); px(13, 7); px(14, 7);
        px(2, 8); px(3, 8); px(4, 8); px(5, 8); px(6, 8); px(7, 8); px(8, 8); px(9, 8); px(10, 8); px(11, 8); px(12, 8); px(13, 8);
        px(3, 9); px(4, 9); px(5, 9); px(6, 9); px(7, 9); px(8, 9); px(9, 9); px(10, 9); px(11, 9); px(12, 9);
        px(4, 10); px(5, 10); px(6, 10); px(7, 10); px(8, 10); px(9, 10); px(10, 10); px(11, 10);
        px(5, 11); px(6, 11); px(7, 11); px(8, 11); px(9, 11); px(10, 11);
        px(6, 12); px(7, 12); px(8, 12); px(9, 12);
        px(7, 13); px(8, 13);
        cctx.fillStyle = red;
        px(4, 3); px(5, 3); px(6, 3); px(7, 3); px(8, 3); px(9, 3); px(10, 3); px(11, 3);
        px(2, 4); px(3, 4); px(4, 4); px(5, 4); px(6, 4); px(7, 4); px(8, 4); px(9, 4); px(10, 4); px(11, 4); px(12, 4); px(13, 4);
        px(2, 5); px(3, 5); px(4, 5); px(5, 5); px(6, 5); px(7, 5); px(8, 5); px(9, 5); px(10, 5); px(11, 5); px(12, 5); px(13, 5);
        px(3, 6); px(4, 6); px(5, 6); px(6, 6); px(7, 6); px(8, 6); px(9, 6); px(10, 6); px(11, 6); px(12, 6); px(13, 6);
        px(4, 7); px(5, 7); px(6, 7); px(7, 7); px(8, 7); px(9, 7); px(10, 7); px(11, 7); px(12, 7);
        px(5, 8); px(6, 8); px(7, 8); px(8, 8); px(9, 8); px(10, 8); px(11, 8);
        px(6, 9); px(7, 9); px(8, 9); px(9, 9); px(10, 9);
        px(7, 10); px(8, 10); px(9, 10);
        px(7, 11); px(8, 11);
        cctx.fillStyle = highlight;
        px(5, 4); px(6, 4); px(5, 5); px(6, 5);
        return c.toDataURL('image/png');
    }

    // ---- Sprite loader: Mario, bricks (ground), tiles (clouds/pipes) from assets; heart generated ----
    const sprites = { character: null, ground: null, tiles: null, heart: null };
    var loadPending = 4;

    function onSpriteLoad() {
        loadPending--;
        if (loadPending === 0) {
            document.getElementById('loadingText').textContent = '';
            document.getElementById('startBtn').disabled = false;
        }
    }

    (function loadSprites() {
        var mario = new Image();
        mario.onload = function() { sprites.character = mario; useFallbackCharacter = false; onSpriteLoad(); };
        mario.onerror = function() {
            useFallbackCharacter = true;
            var fallback = new Image();
            fallback.onload = function() { sprites.character = fallback; onSpriteLoad(); };
            fallback.src = generateCharacterSheetFallback();
        };
        mario.src = 'assets/mario.png';

        var groundImg = new Image();
        groundImg.onload = function() { sprites.ground = groundImg; onSpriteLoad(); };
        groundImg.onerror = function() {
            var fb = new Image();
            fb.onload = function() { sprites.ground = fb; onSpriteLoad(); };
            fb.src = generateGroundTile();
        };
        groundImg.src = 'assets/bricks.png';

        var tilesImg = new Image();
        tilesImg.onload = function() { sprites.tiles = tilesImg; onSpriteLoad(); };
        tilesImg.onerror = function() { sprites.tiles = null; onSpriteLoad(); };
        tilesImg.src = 'assets/tiles.png';

        var heartImg = new Image();
        heartImg.onload = function() { sprites.heart = heartImg; onSpriteLoad(); };
        heartImg.src = generateHeartSprite();
    })();

    // ---- Constants ----
    const GRAVITY = 0.6;
    const JUMP_STRENGTH = -12;
    const SCROLL_SPEED = 4;
    const TILE_W = 40;
    const TILE_H = 40;
    const CHAR_DISPLAY_W = 32;
    const CHAR_DISPLAY_H = 48;
    const HEART_W = 32;
    const HEART_H = 32;

    let GROUND_Y;

    const MEMORIES = [
        { title: "College Days üìö", text: "Where it all began... Project group partners who became inseparable best friends for 4 amazing years! üìö‚ú®" },
        { title: "Our First Date ü•ü", text: "Remember that beautiful day at the park by the lake? And those delicious momos at momo.i.am? ü•üüíï" },
        { title: "Pariah Night üéµ", text: "Your first time getting high with me... Steven Wilson's 'Pariah' playing... That magical connection we felt üéµüåô" },
        { title: "Lake Talks üåÖ", text: "All those walks around college, deep conversations by the lake. Hours felt like minutes with you üåÖüí≠" },
        { title: "Ooty Adventure üèîÔ∏è", text: "Our first trip together! Mountains, mist, and making memories that would last forever üèîÔ∏è‚ù§Ô∏è" },
        { title: "Goa Beach Race üèñÔ∏è", text: "Racing on the beach just for fun, feeling free and alive. Pure joy in the simplest moments üèñÔ∏èüèÉ" },
        { title: "Horror Movie Nights üé¨", text: "Our favorite thing - getting scared together during horror movies, holding each other close üé¨üëª" }
    ];

    // Pipes rising from ground (world X; spaced with gaps)
    const PIPE_XS = [500, 1600, 3000, 4600, 6200];
    const PIPE_W = 48;
    const PIPE_H = 96;

    // Brick platforms (yOff = offset from GROUND_Y; higher = more negative)
    const BRICK_PLATFORMS = [
        { x: 950, yOff: -112, w: 120, h: 24 },
        { x: 2100, yOff: -136, w: 120, h: 24 },
        { x: 3700, yOff: -120, w: 140, h: 24 },
        { x: 5300, yOff: -104, w: 120, h: 24 }
    ];

    // Platform strips with heart block in middle (----^--): x, yOff, numBlocks (40px each), index of ? block
    const HEART_PLATFORMS = [
        { x: 670, yOff: -148, numBlocks: 5, heartIndex: 2 },
        { x: 1870, yOff: -168, numBlocks: 5, heartIndex: 2 },
        { x: 3120, yOff: -158, numBlocks: 5, heartIndex: 2 },
        { x: 4320, yOff: -178, numBlocks: 5, heartIndex: 2 },
        { x: 5520, yOff: -148, numBlocks: 5, heartIndex: 2 },
        { x: 6820, yOff: -168, numBlocks: 5, heartIndex: 2 },
        { x: 8120, yOff: -158, numBlocks: 5, heartIndex: 2 }
    ];
    // Mountain steps to cross (hill; with gaps between sections)
    const MOUNTAIN_BLOCKS = [
        { x: 2550, yOff: -40, w: 80, h: 40 },
        { x: 2650, yOff: -80, w: 80, h: 40 },
        { x: 2750, yOff: -120, w: 80, h: 40 },
        { x: 2850, yOff: -80, w: 80, h: 40 },
        { x: 2950, yOff: -40, w: 80, h: 40 }
    ];

    // End of level: triangular mountain (ground blocks), then flagpole, then castle
    const TRIANGLE_MOUNTAIN_LEFT = 8600;
    const TRIANGLE_MOUNTAIN_BASE_BLOCKS = 11;
    const TRIANGLE_MOUNTAIN_ROWS = 6;
    const FLAGPOLE_X = 8960;
    const FLAGPOLE_H = 380;
    const FLAG_DISPLAY_W = 56;
    const FLAG_DISPLAY_H = 44;
    const CASTLE_X = 9000;
    const CASTLE_W = 320;
    const CASTLE_H = 300;
    // tiles.png (411x949): castles bottom, flagpoles row above. Pipes: green rim/body.
    const TILES_CASTLE = { sx: 0, sy: 760, sw: 205, sh: 189 };
    const TILES_FLAGPOLE_POLE = { sx: 10, sy: 675, sw: 24, sh: 135 };
    const TILES_FLAGPOLE_FLAG = { sx: 38, sy: 675, sw: 40, sh: 28 };
    const TILES_FLAGPOLE_BASE = { sx: 0, sy: 780, sw: 102, sh: 30 };
    const TILES_PIPE_RIM = { sx: 309, sy: 417, sw: 32, sh: 16 };
    const TILES_PIPE_BODY = { sx: 309, sy: 433, sw: 32, sh: 15 };

    let gameState = {
        running: false,
        paused: false,
        heartsCollected: 0,
        totalHearts: 7,
        scrollOffset: 0,
        animTime: 0,
        flagReached: false,
        flagSliding: false,
        flagY: 0
    };

    let player = {
        x: 100,
        y: 0,
        width: CHAR_DISPLAY_W,
        height: CHAR_DISPLAY_H,
        velocityY: 0,
        jumping: false,
        isAirborne: false,
        facing: 1
    };

    let hearts = [];
    let questionBlockHit = []; // one bool per block: true after hit from below
    let gameLoopId = null;

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        GROUND_Y = canvas.height - 80;
        if (typeof player !== 'undefined' && player.y === 0) player.y = GROUND_Y;
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', resizeCanvas);

    function initHearts() {
        questionBlockHit = HEART_PLATFORMS.map(function() { return false; });
        hearts = HEART_PLATFORMS.map(function(plat, i) {
            const blockCenterX = plat.x + plat.heartIndex * TILE_W + TILE_W / 2;
            return {
                memoryId: i,
                x: blockCenterX - HEART_W / 2,
                y: GROUND_Y + plat.yOff - HEART_H - 8,
                width: HEART_W,
                height: HEART_H,
                collected: false,
                released: false,
                angle: Math.random() * Math.PI * 2
            };
        });
    }

    function drawSky() {
        const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
        g.addColorStop(0, '#5C94E3');
        g.addColorStop(1, '#B4D8F7');
        ctx.fillStyle = g;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawClouds() {
        var t = sprites.tiles;
        var scale = 2;
        var basePos = [100, 500, 900, 1400, 2000, 2600, 3200, 3800, 4500];
        if (t && t.complete) {
            basePos.forEach(function(baseX) {
                var x = baseX - gameState.scrollOffset * 0.3;
                var y = 60;
                ctx.drawImage(t, 211, 69, 8, 24, x, y, 8 * scale, 24 * scale);
                ctx.drawImage(t, 219, 69, 16, 24, x + 8 * scale, y, 16 * scale, 24 * scale);
                ctx.drawImage(t, 219, 69, 16, 24, x + 24 * scale, y, 16 * scale, 24 * scale);
                ctx.drawImage(t, 235, 69, 8, 24, x + 40 * scale, y, 8 * scale, 24 * scale);
            });
        } else {
            ctx.fillStyle = '#FFFFFF';
            basePos.forEach(function(baseX) {
                var x = baseX - gameState.scrollOffset * 0.3;
                var y = 70;
                ctx.beginPath();
                ctx.arc(x, y + 5, 18, 0, Math.PI * 2);
                ctx.arc(x + 22, y, 22, 0, Math.PI * 2);
                ctx.arc(x + 48, y + 5, 18, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillRect(x - 8, y + 2, 72, 14);
            });
        }
    }

    function drawPipes() {
        var t = sprites.tiles;
        var scale = 2;
        PIPE_XS.forEach(function(worldX, idx) {
            var x = worldX - gameState.scrollOffset;
            if (x + PIPE_W * scale < 0 || x > canvas.width) return;
            if (t && t.complete) {
                var rim = TILES_PIPE_RIM, body = TILES_PIPE_BODY;
                var smooth = ctx.imageSmoothingEnabled;
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(t, rim.sx, rim.sy, rim.sw, rim.sh, x, GROUND_Y - PIPE_H, rim.sw * scale, rim.sh * scale);
                ctx.drawImage(t, body.sx, body.sy, body.sw, body.sh, x, GROUND_Y - PIPE_H + 32, body.sw * scale, body.sh * scale);
                ctx.drawImage(t, body.sx, body.sy, body.sw, body.sh, x, GROUND_Y - PIPE_H + 64, body.sw * scale, body.sh * scale);
                ctx.imageSmoothingEnabled = smooth;
            } else {
                var fill = idx % 2 === 0 ? '#00A800' : '#6A6A6A';
                var dark = idx % 2 === 0 ? '#006000' : '#4A4A4A';
                ctx.fillStyle = fill;
                ctx.fillRect(x, GROUND_Y - PIPE_H, PIPE_W, PIPE_H);
                ctx.fillStyle = dark;
                ctx.fillRect(x - 4, GROUND_Y - PIPE_H - 6, PIPE_W + 8, 10);
                ctx.fillStyle = fill;
            }
        });
    }

    function drawCastle() {
        var dx = CASTLE_X - gameState.scrollOffset;
        if (dx + CASTLE_W < 0 || dx > canvas.width + 50) return;
        var baseY = GROUND_Y - CASTLE_H + 24;
        var t = sprites.tiles;
        if (t && t.complete) {
            var r = TILES_CASTLE;
            var imgW = t.naturalWidth || 411;
            var imgH = t.naturalHeight || 949;
            var sx = Math.max(0, r.sx);
            var sy = Math.max(0, r.sy);
            var sw = Math.min(r.sw, imgW - sx);
            var sh = Math.min(r.sh, imgH - sy);
            if (sw > 0 && sh > 0) {
                var smooth = ctx.imageSmoothingEnabled;
                ctx.imageSmoothingEnabled = false;
                ctx.drawImage(t, sx, sy, sw, sh, dx, baseY, CASTLE_W, CASTLE_H);
                ctx.imageSmoothingEnabled = smooth;
            }
        } else {
            var tw = TILE_W, th = TILE_H;
            var img = sprites.ground;
            var sw = (img && img.complete && img.naturalWidth === 80) ? 16 : tw;
            var sh = (img && img.complete && img.naturalWidth === 80) ? 16 : th;
            for (var cx = 0; cx < CASTLE_W; cx += tw) {
                for (var cy = 0; cy < CASTLE_H; cy += th) {
                    if (img && img.complete) {
                        ctx.drawImage(img, 0, 0, sw, sh, dx + cx, baseY + cy, tw, th);
                        ctx.fillStyle = 'rgba(0,0,0,0.45)';
                        ctx.fillRect(dx + cx, baseY + cy, tw, th);
                    } else {
                        ctx.fillStyle = '#4A4A4A';
                        ctx.fillRect(dx + cx, baseY + cy, tw, th);
                    }
                }
            }
            var doorW = 72, doorH = 80;
            var doorX = dx + (CASTLE_W - doorW) / 2;
            var doorY = baseY + CASTLE_H - doorH - 24;
            ctx.fillStyle = '#0D0D0D';
            ctx.fillRect(doorX, doorY, doorW, doorH);
        }
    }

    function drawBrickPlatforms() {
        var img = sprites.ground;
        var tw = TILE_W, th = TILE_H;
        var sw = (img && img.complete && img.naturalWidth === 80) ? 16 : tw;
        var sh = (img && img.complete && img.naturalWidth === 80) ? 16 : th;
        function drawPlatform(x, y, w, h) {
            x = x - gameState.scrollOffset;
            if (x + w < 0 || x > canvas.width) return;
            if (!img || !img.complete) {
                ctx.fillStyle = '#C87838';
                ctx.fillRect(x, y, w, h);
                ctx.strokeStyle = '#8B4513';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, w, h);
            } else {
                for (var cx = 0; cx < w; cx += tw) {
                    for (var cy = 0; cy < h; cy += th) {
                        ctx.drawImage(img, 0, 0, sw, sh, x + cx, y + cy, tw, th);
                    }
                }
            }
        }
        BRICK_PLATFORMS.forEach(function(p) {
            drawPlatform(p.x, GROUND_Y + p.yOff, p.w, p.h);
        });
    }

    function drawHeartPlatforms() {
        var img = sprites.ground;
        var tw = TILE_W, th = TILE_H;
        var sw = (img && img.complete && img.naturalWidth === 80) ? 16 : tw;
        var sh = (img && img.complete && img.naturalWidth === 80) ? 16 : th;
        HEART_PLATFORMS.forEach(function(plat, i) {
            var baseX = plat.x - gameState.scrollOffset;
            if (baseX + plat.numBlocks * tw < 0 || baseX > canvas.width) return;
            var y = GROUND_Y + plat.yOff;
            for (var col = 0; col < plat.numBlocks; col++) {
                var x = baseX + col * tw;
                if (x + tw < 0 || x > canvas.width) continue;
                var isHeartBlock = col === plat.heartIndex;
                var hit = isHeartBlock && questionBlockHit[i];
                if (isHeartBlock) {
                    if (hit) {
                        ctx.fillStyle = '#8B6914';
                        ctx.fillRect(x, y, tw, th);
                        ctx.strokeStyle = '#5C4033';
                    } else {
                        ctx.fillStyle = '#C87838';
                        ctx.fillRect(x, y, tw, th);
                        ctx.strokeStyle = '#8B4513';
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold ' + (th * 0.5) + 'px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillText('?', x + tw / 2, y + th * 0.72);
                        ctx.textAlign = 'left';
                    }
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, tw, th);
                } else {
                    if (img && img.complete) {
                        ctx.drawImage(img, 0, 0, sw, sh, x, y, tw, th);
                    } else {
                        ctx.fillStyle = '#C87838';
                        ctx.fillRect(x, y, tw, th);
                        ctx.strokeStyle = '#8B4513';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, y, tw, th);
                    }
                }
            }
        });
    }

    function drawTriangleMountain() {
        var img = sprites.ground;
        var baseLeft = TRIANGLE_MOUNTAIN_LEFT - gameState.scrollOffset;
        if (baseLeft + TRIANGLE_MOUNTAIN_BASE_BLOCKS * TILE_W < 0 || baseLeft > canvas.width) return;
        var tw = TILE_W, th = TILE_H;
        var sw = (img && img.complete && img.naturalWidth === 80) ? 16 : tw;
        var sh = (img && img.complete && img.naturalWidth === 80) ? 16 : th;
        var centerX = baseLeft + (TRIANGLE_MOUNTAIN_BASE_BLOCKS * tw) / 2;
        for (var row = 0; row < TRIANGLE_MOUNTAIN_ROWS; row++) {
            var blocksInRow = TRIANGLE_MOUNTAIN_BASE_BLOCKS - 2 * row;
            if (blocksInRow < 1) break;
            var rowY = GROUND_Y - (row + 1) * th;
            var rowLeft = centerX - (blocksInRow * tw) / 2;
            for (var col = 0; col < blocksInRow; col++) {
                var tx = rowLeft + col * tw;
                if (tx + tw < 0 || tx > canvas.width) continue;
                if (img && img.complete) {
                    ctx.drawImage(img, 0, 0, sw, sh, tx, rowY, tw, th);
                } else {
                    ctx.fillStyle = '#8B7355';
                    ctx.fillRect(tx, rowY, tw, th);
                    ctx.strokeStyle = '#5C4033';
                    ctx.strokeRect(tx, rowY, tw, th);
                }
            }
        }
    }

    function drawFlagpole() {
        var x = FLAGPOLE_X - gameState.scrollOffset;
        if (x + 80 < 0 || x > canvas.width) return;
        var poleW = 16;
        var poleTop = GROUND_Y - FLAGPOLE_H;
        var flagY = gameState.flagSliding ? gameState.flagY : poleTop;
        var baseH = 40;
        var t = sprites.tiles;
        if (t && t.complete) {
            var imgW = t.naturalWidth || 411;
            var imgH = t.naturalHeight || 949;
            var poleR = TILES_FLAGPOLE_POLE;
            var baseR = TILES_FLAGPOLE_BASE;
            var flagR = TILES_FLAGPOLE_FLAG;
            var smooth = ctx.imageSmoothingEnabled;
            ctx.imageSmoothingEnabled = false;
            function drawTile(r, destX, destY, destW, destH) {
                var sx = Math.max(0, Math.min(r.sx, imgW - 1));
                var sy = Math.max(0, Math.min(r.sy, imgH - 1));
                var sw = Math.min(r.sw, imgW - sx);
                var sh = Math.min(r.sh, imgH - sy);
                if (sw > 0 && sh > 0) ctx.drawImage(t, sx, sy, sw, sh, destX, destY, destW, destH);
            }
            drawTile(baseR, x - 6, GROUND_Y - baseH, 56, baseH);
            drawTile(poleR, x, poleTop, poleW, FLAGPOLE_H);
            drawTile(flagR, x + poleW, flagY, FLAG_DISPLAY_W, FLAG_DISPLAY_H);
            ctx.imageSmoothingEnabled = smooth;
        } else {
            ctx.fillStyle = '#8B6914';
            ctx.fillRect(x - 4, GROUND_Y - baseH, poleW + 8, baseH);
            ctx.strokeStyle = '#5C4033';
            ctx.strokeRect(x - 4, GROUND_Y - baseH, poleW + 8, baseH);
            ctx.fillStyle = '#C0C0C0';
            ctx.fillRect(x, poleTop, poleW, FLAGPOLE_H);
            ctx.fillStyle = '#808080';
            ctx.strokeRect(x, poleTop, poleW, FLAGPOLE_H);
            ctx.fillStyle = '#E52521';
            ctx.fillRect(x + poleW, flagY, FLAG_DISPLAY_W, FLAG_DISPLAY_H);
            ctx.fillStyle = '#8B0000';
            ctx.strokeRect(x + poleW, flagY, FLAG_DISPLAY_W, FLAG_DISPLAY_H);
        }
    }

    function drawMountainBlocks() {
        var img = sprites.ground;
        MOUNTAIN_BLOCKS.forEach(function(p) {
            var x = p.x - gameState.scrollOffset;
            if (x + p.w < 0 || x > canvas.width) return;
            var y = GROUND_Y + p.yOff;
            if (!img || !img.complete) {
                ctx.fillStyle = '#8B7355';
                ctx.fillRect(x, y, p.w, p.h);
                ctx.strokeStyle = '#5C4033';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, p.w, p.h);
            } else {
                var tw = TILE_W, th = TILE_H;
                var sw = img.naturalWidth === 80 ? 16 : tw, sh = img.naturalWidth === 80 ? 16 : th;
                for (var cx = 0; cx < p.w; cx += tw) {
                    for (var cy = 0; cy < p.h; cy += th) {
                        ctx.drawImage(img, 0, 0, sw, sh, x + cx, y + cy, tw, th);
                    }
                }
            }
        });
    }

    function drawGroundTiles() {
        if (!sprites.ground || !sprites.ground.complete) return;
        var img = sprites.ground;
        var sw = img.naturalWidth === 80 ? 16 : TILE_W;
        var sh = img.naturalWidth === 80 ? 16 : TILE_H;
        const startCol = Math.floor(gameState.scrollOffset / TILE_W);
        const numCols = Math.ceil(canvas.width / TILE_W) + 2;
        const rows = Math.ceil((canvas.height - GROUND_Y) / TILE_H) + 1;
        for (let col = -1; col <= numCols; col++) {
            for (let row = 0; row < rows; row++) {
                const sx = (startCol + col) * TILE_W - gameState.scrollOffset;
                const sy = GROUND_Y + row * TILE_H;
                if (sx + TILE_W < 0 || sx > canvas.width) continue;
                ctx.drawImage(img, 0, 0, sw, sh, sx, sy, TILE_W, TILE_H);
            }
        }
    }

    function drawHearts() {
        if (!sprites.heart || !sprites.heart.complete) return;
        var smooth = ctx.imageSmoothingEnabled;
        ctx.imageSmoothingEnabled = false;
        hearts.forEach(function(heart) {
            if (heart.collected || !heart.released) return;
            const x = heart.x - gameState.scrollOffset;
            if (x + HEART_W < 0 || x > canvas.width) return;
            heart.angle += 0.05;
            const scale = 1 + Math.sin(heart.angle) * 0.12;
            ctx.save();
            ctx.translate(x + HEART_W / 2, heart.y + HEART_H / 2);
            ctx.scale(scale, scale);
            ctx.drawImage(sprites.heart, 0, 0, 16, 16, -HEART_W / 2, -HEART_H / 2, HEART_W, HEART_H);
            ctx.restore();
        });
        ctx.imageSmoothingEnabled = smooth;
    }

    function drawPlayer() {
        if (!sprites.character || !sprites.character.complete) return;
        const screenX = player.x - gameState.scrollOffset;
        if (screenX + CHAR_DISPLAY_W < 0 || screenX > canvas.width) return;
        var r, dw, dh, dy, img = sprites.character;
        var faceRight = player.facing === 1;
        if (useFallbackCharacter) {
            var frame = player.isAirborne ? 4 : Math.floor(gameState.animTime / 8) % 4;
            var w = 32, h = 48;
            var drawY = player.y - h;
            if (faceRight) {
                ctx.save();
                ctx.translate(screenX + w / 2, drawY + h / 2);
                ctx.scale(-1, 1);
                ctx.translate(-(screenX + w / 2), -(drawY + h / 2));
                ctx.drawImage(img, frame * 32, 0, w, h, screenX, drawY, w, h);
                ctx.restore();
            } else {
                ctx.drawImage(img, frame * 32, 0, w, h, screenX, drawY, w, h);
            }
            return;
        }
        if (player.isAirborne) {
            r = MARIO_JUMP_FRAME;
            dw = CHAR_DISPLAY_W;
            dh = CHAR_DISPLAY_H;
            dy = player.y - CHAR_DISPLAY_H;
        } else {
            r = MARIO_RUN_FRAMES[Math.floor(gameState.animTime / 8) % MARIO_RUN_FRAMES.length];
            dw = CHAR_DISPLAY_W;
            dh = r[3] * (CHAR_DISPLAY_W / r[2]);
            dy = player.y - dh;
        }
        var sy = img.naturalHeight - r[1] - r[3];
        if (faceRight) {
            ctx.save();
            ctx.translate(screenX + dw / 2, dy + dh / 2);
            ctx.scale(-1, 1);
            ctx.translate(-(screenX + dw / 2), -(dy + dh / 2));
            ctx.drawImage(img, r[0], sy, r[2], r[3], screenX, dy, dw, dh);
            ctx.restore();
        } else {
            ctx.drawImage(img, r[0], sy, r[2], r[3], screenX, dy, dw, dh);
        }
    }

    var keys = { left: false, right: false };

    function updatePlayer() {
        var poleW = 16;
        var poleTopY = GROUND_Y - FLAGPOLE_H;

        if (gameState.flagSliding) {
            gameState.flagY += 6;
            player.x = FLAGPOLE_X - 6;
            player.y = gameState.flagY - player.height + 10;
            if (gameState.flagY >= GROUND_Y - FLAG_DISPLAY_H) {
                gameState.flagSliding = false;
                gameState.running = false;
                document.getElementById('endScreen').classList.remove('hidden');
            }
            gameState.scrollOffset = Math.max(0, player.x - 200);
            gameState.animTime++;
            return;
        }

        if (gameState.flagReached) {
            gameState.scrollOffset = Math.max(0, player.x - 200);
            gameState.animTime++;
            return;
        }

        if (!gameState.flagReached && player.x + player.width >= FLAGPOLE_X && player.x <= FLAGPOLE_X + poleW + 24) {
            gameState.flagReached = true;
            gameState.flagSliding = true;
            gameState.flagY = poleTopY;
            player.x = FLAGPOLE_X - 6;
            player.velocityY = 0;
            gameState.scrollOffset = Math.max(0, player.x - 200);
            gameState.animTime++;
            return;
        }

        if (keys.right && !keys.left) {
            player.x += SCROLL_SPEED;
            player.facing = 1;
        } else if (keys.left && !keys.right) {
            player.x -= SCROLL_SPEED;
            player.facing = -1;
        }
        player.x = Math.max(100, player.x);
        player.velocityY += GRAVITY;
        player.y += player.velocityY;

        var footY = player.y;
        var headY = player.y - player.height;
        var left = player.x;
        var right = player.x + player.width;

        function getTriangleMountainPlatforms() {
            var list = [];
            var tw = TILE_W, th = TILE_H;
            var centerWorld = TRIANGLE_MOUNTAIN_LEFT + (TRIANGLE_MOUNTAIN_BASE_BLOCKS * tw) / 2;
            for (var row = 0; row < TRIANGLE_MOUNTAIN_ROWS; row++) {
                var blocksInRow = TRIANGLE_MOUNTAIN_BASE_BLOCKS - 2 * row;
                if (blocksInRow < 1) break;
                var rowY = GROUND_Y - (row + 1) * th;
                var rowLeftWorld = centerWorld - (blocksInRow * tw) / 2;
                for (var col = 0; col < blocksInRow; col++) {
                    list.push({ x: rowLeftWorld + col * tw, y: rowY, w: tw, h: th });
                }
            }
            return list;
        }
        function getPlatforms() {
            var list = [];
            BRICK_PLATFORMS.forEach(function(p) {
                list.push({ x: p.x, y: GROUND_Y + p.yOff, w: p.w, h: p.h });
            });
            HEART_PLATFORMS.forEach(function(p) {
                list.push({ x: p.x, y: GROUND_Y + p.yOff, w: p.numBlocks * TILE_W, h: TILE_H });
            });
            MOUNTAIN_BLOCKS.forEach(function(p) {
                list.push({ x: p.x, y: GROUND_Y + p.yOff, w: p.w, h: p.h });
            });
            getTriangleMountainPlatforms().forEach(function(p) {
                list.push(p);
            });
            PIPE_XS.forEach(function(px) {
                list.push({ x: px, y: GROUND_Y - PIPE_H, w: PIPE_W, h: 0 });
            });
            return list;
        }

        if (player.velocityY >= 0) {
            var platforms = getPlatforms();
            var onGround = false;
            if (footY >= GROUND_Y) {
                player.y = GROUND_Y;
                player.velocityY = 0;
                player.jumping = false;
                onGround = true;
            }
            if (!onGround) {
                platforms.forEach(function(plat) {
                    var platTop = plat.y;
                    if (right > plat.x && left < plat.x + plat.w && headY < platTop + (plat.h || 1) && footY >= platTop - 4 && footY <= platTop + 20) {
                        player.y = platTop;
                        player.velocityY = 0;
                        player.jumping = false;
                        onGround = true;
                    }
                });
            }
            if (!onGround) player.isAirborne = true;
        } else {
            player.isAirborne = true;
        }
        if (player.y < GROUND_Y) player.isAirborne = true;

        PIPE_XS.forEach(function(px) {
            var pipeLeft = px, pipeRight = px + PIPE_W;
            if (right > pipeLeft && left < pipeRight) {
                var pipeTop = GROUND_Y - PIPE_H;
                if (footY > pipeTop && headY < GROUND_Y) {
                    if (player.x + player.width * 0.5 < px + PIPE_W * 0.5) {
                        player.x = px - player.width;
                    } else {
                        player.x = pipeRight;
                    }
                }
            }
        });

        getTriangleMountainPlatforms().forEach(function(block) {
            var blockLeft = block.x, blockRight = block.x + block.w;
            var blockTop = block.y, blockBottom = block.y + block.h;
            if (right > blockLeft && left < blockRight && headY < blockBottom && footY > blockTop) {
                if (player.x + player.width * 0.5 < blockLeft + block.w * 0.5) {
                    player.x = blockLeft - player.width;
                } else {
                    player.x = blockRight;
                }
            }
        });

        if (player.velocityY < 0) {
            HEART_PLATFORMS.forEach(function(plat, i) {
                if (questionBlockHit[i]) return;
                var qx = plat.x + plat.heartIndex * TILE_W;
                var blockTop = GROUND_Y + plat.yOff;
                var blockBottom = blockTop + TILE_H;
                if (headY <= blockBottom && headY >= blockBottom - 36 && right > qx && left < qx + TILE_W) {
                    player.y = blockBottom + player.height + 2;
                    player.velocityY = 0;
                    questionBlockHit[i] = true;
                    hearts[i].released = true;
                    hearts[i].y = blockTop - HEART_H - 8;
                }
            });
        }

        gameState.scrollOffset = Math.max(0, player.x - 200);
        gameState.animTime++;
    }

    function checkHeartCollision() {
        hearts.forEach(function(heart) {
            if (heart.collected || !heart.released) return;
            const dx = (player.x + player.width / 2) - (heart.x + heart.width / 2);
            const dy = (player.y - player.height / 2) - (heart.y + heart.height / 2);
            if (Math.abs(dx) < 28 && Math.abs(dy) < 32) {
                heart.collected = true;
                gameState.heartsCollected++;
                document.getElementById('heartCount').textContent = gameState.heartsCollected;
                showMemory(heart.memoryId);
                gameState.paused = true;
                document.getElementById('instructions').style.display = 'none';
            }
        });
    }

    function showMemory(memoryId) {
        const m = MEMORIES[memoryId];
        document.getElementById('memoryTitle').textContent = m.title;
        document.getElementById('memoryText').textContent = m.text;
        document.getElementById('memoryScreen').classList.remove('hidden');
    }

    function closeMemory() {
        document.getElementById('memoryScreen').classList.add('hidden');
        gameState.paused = false;
        document.getElementById('instructions').style.display = 'block';
        if (gameState.heartsCollected >= 7) {
            gameState.running = false;
            document.getElementById('endScreen').classList.remove('hidden');
        }
    }

    function gameLoop() {
        drawSky();
        drawClouds();
        drawPipes();
        drawFlagpole();
        drawCastle();
        drawMountainBlocks();
        drawBrickPlatforms();
        drawGroundTiles();
        drawTriangleMountain();
        drawHeartPlatforms();
        drawHearts();
        if (gameState.running && !gameState.paused) {
            updatePlayer();
            checkHeartCollision();
        }
        drawPlayer();
        if (gameState.running) gameLoopId = requestAnimationFrame(gameLoop);
        else gameLoopId = null;
    }

    function handleJump() {
        if (player.jumping || gameState.paused || !gameState.running) return;
        player.velocityY = JUMP_STRENGTH;
        player.jumping = true;
    }

    window.startGame = function() {
        document.getElementById('startScreen').classList.add('hidden');
        gameState.running = true;
        gameState.paused = false;
        gameState.heartsCollected = 0;
        gameState.scrollOffset = 0;
        gameState.animTime = 0;
        gameState.flagReached = false;
        gameState.flagSliding = false;
        gameState.flagY = 0;
        document.getElementById('heartCount').textContent = '0';
        player.x = 100;
        player.y = GROUND_Y;
        player.velocityY = 0;
        player.jumping = false;
        initHearts();
        document.getElementById('instructions').style.display = 'block';
        gameLoop();
    };

    window.closeMemory = closeMemory;

    window.restartGame = function() {
        document.getElementById('endScreen').classList.add('hidden');
        document.getElementById('startScreen').classList.remove('hidden');
    };

    canvas.addEventListener('click', handleJump);
    canvas.addEventListener('touchstart', function(e) {
        e.preventDefault();
        handleJump();
    }, { passive: false });
    window.addEventListener('keydown', function(e) {
        if (e.code === 'Space') {
            e.preventDefault();
            var startEl = document.getElementById('startScreen');
            var memoryEl = document.getElementById('memoryScreen');
            var endEl = document.getElementById('endScreen');
            if (!startEl.classList.contains('hidden') && !document.getElementById('startBtn').disabled) {
                startGame();
            } else if (!memoryEl.classList.contains('hidden')) {
                closeMemory();
            } else if (endEl && !endEl.classList.contains('hidden')) {
                restartGame();
            } else {
                handleJump();
            }
        }
        if (e.code === 'ArrowLeft') { e.preventDefault(); keys.left = true; }
        if (e.code === 'ArrowRight') { e.preventDefault(); keys.right = true; }
    });
    window.addEventListener('keyup', function(e) {
        if (e.code === 'ArrowLeft') keys.left = false;
        if (e.code === 'ArrowRight') keys.right = false;
    });
})();
    </script>
</body>
</html>
